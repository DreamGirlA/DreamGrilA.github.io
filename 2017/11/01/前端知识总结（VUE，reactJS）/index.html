<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="VUE,reactJS,ES6," />





  <link rel="alternate" href="/atom.xml" title="Candice Yu_个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/uploads/favicon.ico?v=5.0.1" />






<meta name="description" content="VUE总结VUE和jQuery的区别
jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事">
<meta property="og:type" content="article">
<meta property="og:title" content="前端知识总结（VUE，reactJS，ES6）">
<meta property="og:url" content="http://candiceyu.com/2017/11/01/前端知识总结（VUE，reactJS）/index.html">
<meta property="og:site_name" content="Candice Yu_个人博客">
<meta property="og:description" content="VUE总结VUE和jQuery的区别
jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5285574-10a2d807f0f569ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5285574-5ccc018e2636a353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5285574-62f6cacee675f3e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5285574-9fa2497a7f336c4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5285574-097895cd43e7a0a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-11-01T08:35:13.652Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端知识总结（VUE，reactJS，ES6）">
<meta name="twitter:description" content="VUE总结VUE和jQuery的区别
jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/5285574-10a2d807f0f569ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://candiceyu.com/2017/11/01/前端知识总结（VUE，reactJS）/"/>

  <title> 前端知识总结（VUE，reactJS，ES6） | Candice Yu_个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?516d783fb114015b9b38b2ce58b5fe15";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Candice Yu_个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Candice Yu</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/aboutMe" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                前端知识总结（VUE，reactJS，ES6）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-01T10:41:13+08:00" content="2017-11-01">
              2017-11-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/01/前端知识总结（VUE，reactJS）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/01/前端知识总结（VUE，reactJS）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="VUE总结"><a href="#VUE总结" class="headerlink" title="VUE总结"></a>VUE总结</h1><h2 id="VUE和jQuery的区别"><a href="#VUE和jQuery的区别" class="headerlink" title="VUE和jQuery的区别"></a>VUE和jQuery的区别</h2><blockquote>
<p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。<br>jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。</p>
<p>vue是一个兴起的前端js库，是一个精简的MVVM。从技术角度讲，Vue.js 专注于 MVVM 模型的 ViewModel 层。它通过双向数据绑定把 View 层和 Model 层连接了起来，通过对数据的操作就可以完成对页面视图的渲染。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue 采用自底向上增量开发的设计，（自底向上的程序设计就是先编写出基础程序段，然后再逐步扩大规模、补充和升级某些功能，实际上是一种自底向上构造程序的过程。）它不是一个全能框架——它只聚焦于视图层。</p>
</blockquote>
<ul>
<li><p>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“lable”).val();,它还是依赖DOM元素的值。 </p>
</li>
<li><p>Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm（VM指的是ViewModel：他是view的抽象，负责view和model之间的信息转换，将view的command传送到model）实现相互的绑定。这就是传说中的MVVM。</p>
</li>
</ul>
<h2 id="VUE1-0和VUE2-0的区别"><a href="#VUE1-0和VUE2-0的区别" class="headerlink" title="VUE1.0和VUE2.0的区别"></a>VUE1.0和VUE2.0的区别</h2><ol>
<li>beforeCompile 移除，使用 created 钩子函数替代。</li>
<li>compiled 替换，使用 mounted 钩子函数替代。</li>
<li><p>attached 移除，使用其他钩子函数内置的 DOM 检测(DOM check)方法。例如：</p>
<pre><code>attached: function () {
  doSomething()
}
改为如下：
mounted: function () {
  this.$nextTick(function () {
    doSomething()
  })
}
</code></pre></li>
<li><p>detached 移除,改写方式，基本同上相同。</p>
</li>
<li>init 重新命名，使用新的 beforeCreate 钩子函数替代，本质上 beforeCreate 和 init 完全相同。init 被重新命名是为了和其他的生命周期方法的命名方式保持一致。</li>
<li><p>ready 替换，使用新的 mounted 钩子函数替代。应该注意的是，使用 mounted 并不能保证钩子函数中的 this.$el 在 document 中。为此还应该引入 Vue.nextTick/vm.$nextTick。例如：</p>
<pre><code>mounted: function () {
  this.$nextTick(function () {
    // 代码保证 this.$el 在 document 中
  })
}
</code></pre></li>
<li><p>v-for 遍历数组时的参数顺序 变更，当包含 index 时，之前遍历数组时的参数顺序是 (index, value)。现在是 (value, index) ，来和 JavaScript 的原生数组方法（例如 forEach 和 map）保持一致。</p>
</li>
<li>v-for 范围值 变更，之前，v-for=”number in 10” 的 number 从 0 开始到 9 结束，现在从 1 开始，到 10 结束。</li>
<li>v-bind 的 .once和.sync 修饰符 移除，</li>
<li>修改 Props 弃用。</li>
<li>v-bind 真/假值 变更，在2.0中使用 v-bind 时，只有 null, undefined , 和 false 被看作是假。这意味着，0 和空字符串将被作为真值渲染。比如 v-bind:draggable=”‘’” 将被渲染为 draggable=”true”。注意，对于其它钩子函数 (如 v-if 和 v-show)， 他们依然遵循 js 对真假值判断的一般规则。</li>
<li><p>用 v-on 监听原生事件 变更，现在在组件上使用 v-on 只会监听自定义事件（组件用 $emit 触发的事件）。如果要监听根元素的原生事件，可以使用 .native 修饰符，比如：</p>
<pre><code>&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;
</code></pre></li>
</ol>
<p>13.带有 !important 的v-bind:style 移除，</p>
<pre><code>&lt;p v-bind:style=&quot;{ color: myColor + &apos; !important&apos; }&quot;&gt;hello&lt;/p&gt; //这样写将失效
</code></pre><ol>
<li>transition 参数 替换，Vue 的过渡系统有了彻底的改变，现在通过使用 <transition> 和 <transition-group> 来包裹元素实现过渡效果，而不再使用 transition 属性。</transition-group></transition></li>
</ol>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://upload-images.jianshu.io/upload_images/5285574-10a2d807f0f569ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期展示"><br><img src="http://upload-images.jianshu.io/upload_images/5285574-5ccc018e2636a353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期展示"><br><img src="http://upload-images.jianshu.io/upload_images/5285574-62f6cacee675f3e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期展示"></p>
<ol>
<li><p>beforeCreate 创建前状态 ,el 和 data 并未初始化。 </p>
<blockquote>
<p>可以在这加个loading事件</p>
</blockquote>
</li>
<li><p>created:created 创建完毕状态, 完成了data数据的初始化，el没有</p>
<blockquote>
<p>在这结束loading，还做一些初始化，实现函数自执行 。</p>
</blockquote>
</li>
<li><p>beforeMount 挂载前状态, 完成了el和data初始化。</p>
<blockquote>
<p>这时el还是，应用的虚拟Dom技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。</p>
</blockquote>
</li>
<li><p>mounted 挂载结束状态, 完成挂载。   </p>
<blockquote>
<p>在这发起后端请求，拿回数据，配合路由钩子做一些事情</p>
</blockquote>
</li>
<li><p>beforeUpdate 更新前状态。  </p>
<blockquote>
<p>data里的值被修改后，将会触发update的操作</p>
</blockquote>
</li>
<li><p>updated 更新完成状态 </p>
</li>
<li><p>beforeDestroy 销毁前状态。 </p>
<blockquote>
<p>你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容</p>
</blockquote>
</li>
<li><p>destroyed 销毁完成状态。</p>
<blockquote>
<p>销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。</p>
</blockquote>
</li>
</ol>
<h2 id="计算属性computed-vs-Methods-methods"><a href="#计算属性computed-vs-Methods-methods" class="headerlink" title="计算属性computed: {} vs Methods methods: {}"></a>计算属性computed: {} vs Methods methods: {}</h2><blockquote>
<p>计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
</blockquote>
<p>相比而言，只要发生重新渲染，method 调用总会执行该函数。</p>
<p>我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A ，它需要遍历一个极大的数组和做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用 method 替代。</p>
<h2 id="Computed-属性-vs-Watched-属性"><a href="#Computed-属性-vs-Watched-属性" class="headerlink" title="Computed 属性 vs Watched 属性"></a>Computed 属性 vs Watched 属性</h2><p>Vue 确实提供了一种更通用的方式来观察和响应Vue实例上的数据变动：watch属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的想法是使用 computed 属性而不是命令式的 watch 回调。</p>
<h2 id="key管理可复用的元素"><a href="#key管理可复用的元素" class="headerlink" title="key管理可复用的元素"></a>key管理可复用的元素</h2><p> Vue 提供了一种方式来声明“这两个元素是完全独立的——不要复用它们”。只需添加一个具有唯一值的 key 属性即可</p>
<pre><code>&lt;div id=&quot;key-example&quot;&gt;
    &lt;div&gt;
        &lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;
            &lt;label&gt;Username&lt;/label&gt;
            &lt;input placeholder=&quot;Enter your username&quot;  key=&quot;username-input&quot;&gt;
        &lt;/template&gt;
        &lt;template v-else=&quot;&quot;&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;
        &lt;/template&gt;
    &lt;/div&gt;
    &lt;button @click=&quot;toggleLoginType&quot;&gt;Toggle login type&lt;/button&gt;
&lt;/div&gt;
    &lt;script&gt;
        new Vue({
            el: &apos;#key-example&apos;,
            data: {
                loginType: &apos;username&apos;
            },
            methods: {
                toggleLoginType: function () {
                    return this.loginType = this.loginType === &apos;username&apos; ? &apos;email&apos; : &apos;username&apos;
                }
            }
        })
    &lt;/script&gt;
</code></pre><p>每次切换时，输入框都将被重新渲染，但是label依旧会被复用。</p>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>根据条件展示元素的选项是 v-show 指令</p>
<pre><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;
</code></pre><p>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 是简单地切换元素的 CSS 属性 display 。<strong>v-show 不支持 template标签 语法，也不支持 v-else。</strong></p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， <strong>items 是源数据数组并且 item 是数组元素迭代的别名。</strong><br>v-for 还支持一个可选的第二个参数为当前项的索引。</p>
<pre><code>&lt;ul id=&quot;example-2&quot;&gt;
  &lt;li v-for=&quot;(item, index) in items&quot;&gt;
    {{ friendMessage }} - {{ index }} - {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
var example1 = new Vue({
  el: &apos;#example&apos;,
  data: {
  friendMessage: &apos;friend&apos;,
    items: [
      {message: &apos;candice&apos; },
      {message: &apos;yu&apos; }
    ]
  }
})
</code></pre><p>v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用。</p>
<h2 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h2><h3 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h3><p>v-on 指令监听 DOM 事件，可以接收一个定义的方法来调用</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;!-- `greet` 是在下面定义的方法名 --&gt;
  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;
&lt;/div&gt;
var example = new Vue({
  el: &apos;#example&apos;,
  data: {
    name: &apos;Vue.js&apos;
  },
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指当前 Vue 实例
      alert(&apos;Hello &apos; + this.name + &apos;!&apos;)
      // `event` 是原生 DOM 事件
      if (event) {
        alert(event.target.tagName)
      }
    }
  }
})
// 也可以用 JavaScript 直接调用方法
example2.greet() // -&gt; &apos;Hello Vue.js!&apos;
</code></pre><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节,所以，v-on 提供了事件修饰符,通过由点(.)表示的指令后缀来调用修饰符</p>
<pre><code>&lt;!-- 阻止单击事件冒泡 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;
&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;
&lt;!-- 修饰符可以串联  --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;
&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;
&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;
&lt;!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。</p>
<h3 id="键值修饰符"><a href="#键值修饰符" class="headerlink" title="键值修饰符"></a>键值修饰符</h3><p>在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符，</p>
<pre><code>&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;
&lt;input v-on:keyup.13=&quot;submit&quot;&gt;
&lt;!-- 同上 --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;
&lt;!-- 缩写语法 --&gt;
&lt;input @keyup.enter=&quot;submit&quot;&gt;
</code></pre><p>全部的按键别名：.enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right</p>
<h2 id="表单控件绑定"><a href="#表单控件绑定" class="headerlink" title="表单控件绑定"></a>表单控件绑定</h2><ol>
<li>用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。v-model </li>
<li>本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。</li>
<li><strong>v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值。</strong></li>
<li>因为它会选择 Vue 实例数据来作为具体的值。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</li>
</ol>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><pre><code>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
&lt;p&gt;Message is: {{ message }}&lt;/p&gt;
</code></pre><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>多个勾选框，绑定到同一个数组：</p>
<pre><code>&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;
new Vue({
  el: &apos;...&apos;,
  data: {
    checkedNames: []
  }
})
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/5285574-9fa2497a7f336c4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多选框图片"></p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ol>
<li>.lazy<br>在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步</li>
<li>.number<br>如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值</li>
<li><p>.trim<br>如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</p>
<pre><code>&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre></li>
</ol>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p>
<h3 id="data-必须是函数-通过Vue构造器传入的各种选项大多数都可以在组件里用。-data-是一个例外，它必须是函数。"><a href="#data-必须是函数-通过Vue构造器传入的各种选项大多数都可以在组件里用。-data-是一个例外，它必须是函数。" class="headerlink" title="data 必须是函数,通过Vue构造器传入的各种选项大多数都可以在组件里用。 data 是一个例外，它必须是函数。"></a>data 必须是函数,通过Vue构造器传入的各种选项大多数都可以在组件里用。 data 是一个例外，它必须是函数。</h3><pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
&lt;/div&gt;
var data = { counter: 0 }
Vue.component(&apos;simple-counter&apos;, {
  template: &apos;&lt;button v-on:click=&quot;counter += 1&quot;&gt;{{ counter }}&lt;/button&gt;&apos;,
  data: function () {
  return {
    counter: 0
  }
}
})
new Vue({
  el: &apos;#example&apos;
})
</code></pre><h3 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h3><ol>
<li>组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。</li>
<li>在 Vue 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。下图为它的工作方式：<br><img src="http://upload-images.jianshu.io/upload_images/5285574-097895cd43e7a0a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父子组件"></li>
</ol>
<h3 id="使用-Prop-传递数据"><a href="#使用-Prop-传递数据" class="headerlink" title="使用 Prop 传递数据"></a>使用 Prop 传递数据</h3><p>组件实例的作用域是孤立的。这意味着不能(也不应该)在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的props选项。<br>子组件要显式地用 props 选项声明它期待获得的数据：</p>
<pre><code>Vue.component(&apos;child&apos;, {
  // 声明 props// camelCase in JavaScript
  props: [&apos;myMessage&apos;],
  // 就像 data 一样，prop 可以用在模板内
  // 同样也可以在 vm 实例中像 “this.message” 这样使用
  template: &apos;&lt;span&gt;{{ message }}&lt;/span&gt;&apos;
})
</code></pre><p>然后我们可以这样向它传入一个普通字符串：</p>
<pre><code>&lt;!-- kebab-case in HTML --&gt;
&lt;child my-message=&quot;hello!&quot;&gt;
</code></pre><p>HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名</p>
<h4 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h4><p>在模板中，要动态地绑定父组件的数据到子模板的props，与绑定到任何普通的HTML特性相类似，就是用v-bind。每当父组件的数据变化时，该变化也会传导给子组件</p>
<pre><code> &lt;div&gt;
  &lt;input v-model=&quot;parentMsg&quot;&gt;
  &lt;br&gt;
  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;
&lt;/div&gt;
</code></pre><p>v-bind 的缩写语法通常更简单：</p>
<pre><code>&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;
</code></pre><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><ol>
<li>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。</li>
<li>另外，每次父组件更新时，子组件的所有prop都会更新为最新值。这意味着你不应该在子组件内部改变prop。如果你这么做了，Vue会在控制台给出警告。    </li>
<li>为什么我们会有修改prop中数据的冲动呢？通常是这两种原因：</li>
</ol>
<ul>
<li>prop 作为初始值传入后，子组件想把它当作局部数据来用；</li>
<li>prop 作为初始值传入，由子组件处理成其它数据输出。</li>
</ul>
<p>对这两种原因，正确的应对方式是：<br>定义一个局部变量，并用 prop 的值初始化它：</p>
<pre><code>props: [&apos;initialCounter&apos;],
data: function () {
  return { counter: this.initialCounter }
}
</code></pre><p>定义一个计算属性，处理 prop 的值并返回。</p>
<pre><code>props: [&apos;size&apos;],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
</code></pre><h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h3><p>我们可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue 会发出警告。当组件给其他人使用时，这很有用。<br>要指定验证规格，需要用对象的形式，而不能用字符串数组：</p>
<pre><code>Vue.component(&apos;example&apos;, {
  props: {
    // 基础类型检测 （`null` 意思是任何类型都可以）
    propA: Number,
    // 多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: {
      type: String,
      required: true
    },
    // 数字，有默认值
    propD: {
      type: Number,
      default: 100
    },
    // 数组／对象的默认值应当由一个工厂函数返回
    propE: {
      type: Object,
      default: function () {
        return { message: &apos;hello&apos; }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        return value &gt; 10
      }
    }
  }
})
</code></pre><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>父组件是使用props传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件</p>
<ol>
<li><p>使用 v-on 绑定自定义事件<br> 每个 Vue 实例都实现了事件接口(Events interface)，即：</p>
<pre><code>使用 $on(eventName) 监听事件
使用 $emit(eventName) 触发事件
</code></pre></li>
</ol>
<h2 id="子组件索引"><a href="#子组件索引" class="headerlink" title="子组件索引"></a>子组件索引</h2><p>尽管有 props 和 events，但是有时仍然需要在JavaScript中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 。例如：</p>
<pre><code>&lt;div id=&quot;parent&quot;&gt;
  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;
&lt;/div&gt;
var parent = new Vue({ el: &apos;#parent&apos; })
// 访问子组件
var child = parent.$refs.profile
</code></pre><p>当 ref 和 v-for 一起使用时， ref 是一个数组，包含相应的子组件。</p>
<h2 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h2><h3 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h3><blockquote>
<ol>
<li>Vue.js（是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。</li>
<li>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</li>
</ol>
</blockquote>
<h3 id="VueJS-特性："><a href="#VueJS-特性：" class="headerlink" title="VueJS 特性："></a>VueJS 特性：</h3><ul>
<li>MVVM模式（数据变量（model）发生改变 视图（view）也改变，视图（view）改变，数据变量（model）也发生改变）</li>
<li>组件化</li>
<li>指令系统</li>
<li>vue2.0开始支持虚拟dom，vue1.0是操作的是真的dom元素而不是虚拟的<br>虚拟dom：可以提升页面的刷新速度</li>
</ul>
<h4 id="使用MVVM模式有几大好处"><a href="#使用MVVM模式有几大好处" class="headerlink" title="使用MVVM模式有几大好处"></a>使用MVVM模式有几大好处</h4><p>　　1. 低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。<br>　　2. 可重用性。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。<br>　　3. 独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。<br>　　4. 可测试性。可以针对ViewModel来对界面(View)进行测试</p>
<h4 id="虚拟DOM有利也有弊。"><a href="#虚拟DOM有利也有弊。" class="headerlink" title="虚拟DOM有利也有弊。"></a>虚拟DOM有利也有弊。</h4><ol>
<li>大小 - 其中之一就是更多的功能意味着代码包中更多行的代码。幸运的是，Vue.js 2.0 依旧比 较小（当前版本 21.4kb），并<br>且也正在删除很多东西。</li>
<li>内存 -同样，虚拟DOM需要将现有的DOM拷贝后保存在内存中，这是一个在DOM更新速度和内存使用中的权衡。</li>
<li>并不适用所有情况 - 如果虚拟DOM可以一次性进行批量的修改是非常好的。但是如果是单独的、稀少的更新呢？这样的任何DOM更新都将会使虚拟DOM带来无意义的预计算</li>
</ol>
<h3 id="Vue-js特点"><a href="#Vue-js特点" class="headerlink" title="Vue.js特点"></a>Vue.js特点</h3><p>简洁：页面由HTML模板+Json数据+Vue实例组成<br>数据驱动：自动计算属性和追踪依赖的模板表达式<br>组件化：用可复用、解耦的组件来构造页面<br>轻量：代码量小，不依赖其他库<br>快速：精确有效批量DOM更新<br>模板友好：可通过npm，bower等多种方式安装，很容易融入</p>
<h3 id="vue中的MVVM模式"><a href="#vue中的MVVM模式" class="headerlink" title="vue中的MVVM模式"></a>vue中的MVVM模式</h3><blockquote>
<p>即Model-View-ViewModel。</p>
</blockquote>
<ol>
<li>Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。</li>
<li>ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。</li>
<li>DOM Listeners和Data Bindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</li>
</ol>
<h4 id="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><p>答：一个model+view+viewModel框架，数据模型model，viewModel连接两个<br>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p>
<h3 id="指令和用法"><a href="#指令和用法" class="headerlink" title="指令和用法"></a>指令和用法</h3><h4 id="说出至少4种vue当中的指令和它的用法？"><a href="#说出至少4种vue当中的指令和它的用法？" class="headerlink" title="说出至少4种vue当中的指令和它的用法？"></a>说出至少4种vue当中的指令和它的用法？</h4><p>答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p>
<h4 id="v-show指令，v-if的区别"><a href="#v-show指令，v-if的区别" class="headerlink" title="v-show指令，v-if的区别"></a>v-show指令，v-if的区别</h4><p>条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值</p>
<h4 id="指令v-el的使用"><a href="#指令v-el的使用" class="headerlink" title="指令v-el的使用"></a>指令v-el的使用</h4><p>有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。<br>注意<br>HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。<br>示例：</p>
<pre><code>&lt;span v-el:msg&gt;hello&lt;/span&gt;
&lt;span v-el:other-msg&gt;world&lt;/span&gt;
this.$els.msg.textContent // -&gt; &quot;hello&quot;
this.$els.otherMsg.textContent // -&gt; &quot;world&quot;
this.$els.msg //-&gt;&lt;span&gt;hello&lt;/span&gt;
</code></pre><h4 id="指令keep-alive"><a href="#指令keep-alive" class="headerlink" title="指令keep-alive"></a>指令keep-alive</h4><p>在vue-router写着keep-alive，keep-alive的含义：<br>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令</p>
<component :is="curremtView" keep-alive=""></component>

<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h4 id="vue-router有哪几种导航钩子？"><a href="#vue-router有哪几种导航钩子？" class="headerlink" title="vue-router有哪几种导航钩子？"></a>vue-router有哪几种导航钩子？</h4><p>答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</p>
<h4 id="导航钩子有哪些？它们有哪些参数？"><a href="#导航钩子有哪些？它们有哪些参数？" class="headerlink" title="导航钩子有哪些？它们有哪些参数？"></a>导航钩子有哪些？它们有哪些参数？</h4><p>答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br>参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p>
<h4 id="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"><a href="#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？" class="headerlink" title="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"></a>自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</h4><p>答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives<br>钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）<br>钩子函数参数：el、binding</p>
<h3 id="Vuejs组件"><a href="#Vuejs组件" class="headerlink" title="Vuejs组件"></a>Vuejs组件</h3><blockquote>
<p>vuejs构建组件使用</p>
</blockquote>
<pre><code>Vue.component(&apos;componentName&apos;,{ /*component*/ })；   这里注意一点，组件要先注册再使用
Vue.component(&apos;mine&apos;,{
       template:&apos;#mineTpl&apos;,
       props:[&apos;name&apos;,&apos;title&apos;,&apos;city&apos;,&apos;content&apos;]
    });
 var v=new Vue({
      el:&apos;#vueInstance&apos;,
      data:{
          name:&apos;zhang&apos;,
          title:&apos;this is title&apos;,
         city:&apos;Beijing&apos;,
         content:&apos;these are some desc about Blog&apos;
     }
});
</code></pre><h3 id="认识vuex"><a href="#认识vuex" class="headerlink" title="认识vuex"></a>认识vuex</h3><h4 id="你是怎么认识vuex的？"><a href="#你是怎么认识vuex的？" class="headerlink" title="你是怎么认识vuex的？"></a>你是怎么认识vuex的？</h4><p>答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。<br>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p>
<h4 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h4><p>答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
<h3 id="Vue-js-和-AngularJS-之间的区别是什么"><a href="#Vue-js-和-AngularJS-之间的区别是什么" class="headerlink" title="Vue.js 和 AngularJS 之间的区别是什么?"></a>Vue.js 和 AngularJS 之间的区别是什么?</h3><p>下面是一些选择 Vue 而不是 Angular 的可能原因；</p>
<blockquote>
<ol>
<li>Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织你的应用程序，而不是任何时候都必须遵循 Angular 制定的规则。它仅仅是一个视图层，所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在结合其他库方面它给了你更大的的空间，但相应，你也需要做更多的架构决策。</li>
<li>例如，Vue.js 核心默认不包含路由和 ajax 功能，并且通常假定你在用应用中使用了一个外部的模块构建系统。这可能是最重要的区别</li>
<li>在 API 和内部设计方面，Vue.js 比 Angular 简单得多, 因此你可以快速地掌握它的全部特性并投入开发。</li>
<li>Vue.js 拥有更好的性能，因为它不使用脏检查。当 watcher 越来越多时, Angular 会变得越来越慢，因为作用域内的每一次数据变更，所有的 watcher 都需要被重新求值。Vue 则根本没有这个问题，因为它采用的是基于依赖追踪的观察系统，所以所有的数据变更触发都是独立的，除非它们之间有明确的依赖关系。</li>
<li>Vue.js 中指令和组件的概念区分得更为清晰。指令只负责封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 它拥有自己的视图和数据逻辑。在 Angular 中它们两者间有不少概念上的混淆。</li>
</ol>
</blockquote>
<h3 id="Vue-js-和-React-js-有什么区别"><a href="#Vue-js-和-React-js-有什么区别" class="headerlink" title="Vue.js 和 React.js 有什么区别?"></a>Vue.js 和 React.js 有什么区别?</h3><blockquote>
<ol>
<li>React.js 和 Vue.js 确实有一些相似——它们都提供数据驱动、可组合搭建的视图组件。然而，它们的内部实现是完全不同的。React 是基于 Virtual DOM——一种在内存中描述 DOM 树状态的数据结构。React 中的数据通常被看作是不可变的，而 DOM 操作则是通过 Virtual DOM 的 diff 来计算。</li>
<li>与之相比，Vue.js 中的数据默认是可变的，而数据的变更会直接出发对应的 DOM 更新。相比于 Virtual DOM，Vue.js 使用实际的 DOM 作为模板，并且保持对真实节点的引用来进行数据绑定。</li>
<li>Virtual DOM 提供了一个函数式的描述视图的方法，这很 cool。因为它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图通与数据的同步。它也开辟了 JavaScript 同构应用的可能性。</li>
<li>React 有一个问题就是组件的逻辑和视图结合得非常紧密。对于部分开发者来说，他们可能觉得这是个优点，但对那些像兼顾设计和开发的人来说，还是更偏好模板，因为模板能让我们更好地在视觉上思考设计和 CSS。JSX 和 JavaScript 逻辑的混合干扰了我将代码映射到设计的思维过程。</li>
<li>相反，Vue.js 通过在模板中加入一个轻量级的 DSL (指令系统)，换来一个依旧直观的模板，且能够将逻辑封装进指令和过滤器中。</li>
<li>React 的另一个问题是：由于 DOM 更新完全交由 Virtual DOM 管理，当你真的想要自己控制 DOM 是就有点棘手了（虽然理论上你可以，但这样做时你本质上在对抗 React 的设计思想）。对于需要复杂时间控制的动画来说这就变成了一项很讨人厌的限制。在这方面，Vue.js 允许更多的灵活性，并且有不少用 Vue.js 构建的富交互实例</li>
</ol>
</blockquote>
<h3 id="Vue的双向数据绑定原理是什么？（vue-data是怎么实现的？）"><a href="#Vue的双向数据绑定原理是什么？（vue-data是怎么实现的？）" class="headerlink" title="Vue的双向数据绑定原理是什么？（vue data是怎么实现的？）"></a>Vue的双向数据绑定原理是什么？（vue data是怎么实现的？）</h3><blockquote>
<p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
</blockquote>
<p>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化<br>第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图<br>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。<br>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<h3 id="请详细说下你对vue生命周期的理解？"><a href="#请详细说下你对vue生命周期的理解？" class="headerlink" title="请详细说下你对vue生命周期的理解？"></a>请详细说下你对vue生命周期的理解？</h3><blockquote>
<p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>
</blockquote>
<p>创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。<br>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。<br>更新前/后：当data变化时，会触发beforeUpdate和updated方法。<br>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>
<h3 id="请说下封装-vue-组件的过程？"><a href="#请说下封装-vue-组件的过程？" class="headerlink" title="请说下封装 vue 组件的过程？"></a>请说下封装 vue 组件的过程？</h3><blockquote>
<ol>
<li>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</li>
<li>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</li>
</ol>
</blockquote>
<h3 id="vue-router插件"><a href="#vue-router插件" class="headerlink" title="vue-router插件"></a>vue-router插件</h3><h4 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>答：在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</p>
<h4 id="vue-router是什么？它有哪些组件？"><a href="#vue-router是什么？它有哪些组件？" class="headerlink" title="vue-router是什么？它有哪些组件？"></a>vue-router是什么？它有哪些组件？</h4><p>答：vue用来写路由一个插件。router-link、router-view</p>
<h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><p>路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转router-view本身就是将组件渲染到该位置，想要进行页面跳转，就要将页面渲染到根组件，在起始配置路由时候写到：</p>
<pre><code>var App = Vue.extend({ root });
router.start(App,&apos;#app&apos;);
</code></pre><p>这里首先将根组件注册进来，用于将路由中配置好的各个页面渲染出来，然后将根组件挂载到与#app匹配的元素上。</p>
<h4 id="active-class是哪个组件的属性？嵌套路由怎么定义？"><a href="#active-class是哪个组件的属性？嵌套路由怎么定义？" class="headerlink" title="active-class是哪个组件的属性？嵌套路由怎么定义？"></a>active-class是哪个组件的属性？嵌套路由怎么定义？</h4><p>答：vue-router模块的router-link组件。</p>
<h3 id="vuejs中使用事件名"><a href="#vuejs中使用事件名" class="headerlink" title="vuejs中使用事件名"></a>vuejs中使用事件名</h3><p>在vuejs中，我们经常要绑定一些事件，有时候给DOM元素绑定，有时候给组件绑定。绑定事件在HTML中用v-on:click-“event”,这时evet的名字不要出现大写，因为在1.x中不区分大小写，所以如果我们在HTML写v-on:click=”myEvent”而在js中写myEvent就出错误，所以在vuejs的1.x绑定事件时候，要尽量避免使用大写字母。在2.0中没有该限制！</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="如何让css只在当前组件中起作用"><a href="#如何让css只在当前组件中起作用" class="headerlink" title="如何让css只在当前组件中起作用"></a>如何让css只在当前组件中起作用</h4><p>在每一个vue组件中都可以定义各自的css，js，如果希望组件内写的css只对当前组件起作用，只需要在style中写入scoped，即：&lt; style scoped&gt;&lt; /style&gt;</p>
<h4 id="v-model是什么？怎么使用？-vue中标签怎么绑定事件？"><a href="#v-model是什么？怎么使用？-vue中标签怎么绑定事件？" class="headerlink" title="v-model是什么？怎么使用？ vue中标签怎么绑定事件？"></a>v-model是什么？怎么使用？ vue中标签怎么绑定事件？</h4><p>答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：&lt; input @click=doLog() /&gt;</p>
<h4 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h4><p>答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。<br>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p>
<h4 id="下列关于vue的组件说法不正确的是（-D-）"><a href="#下列关于vue的组件说法不正确的是（-D-）" class="headerlink" title="下列关于vue的组件说法不正确的是（ D   ）"></a>下列关于vue的组件说法不正确的是（ D   ）</h4><p>不一定要写style<br>template视图里可以写多个div容器<br>父组件给子组件传值需定义props属性<br>子组件与父组件通信需定义$emit属性</p>
<h4 id="下面关于vue的声明周期说法不正确的是（-D-）"><a href="#下面关于vue的声明周期说法不正确的是（-D-）" class="headerlink" title="下面关于vue的声明周期说法不正确的是（  D  ）"></a>下面关于vue的声明周期说法不正确的是（  D  ）</h4><p>总共分为8个阶段:创建前/后、载入前/后、更新前/后、销毁前/后、<br>updated和beforeUpdate分别是更新完成和更新前<br>创建后this才可以获取属性、mounted时$el节点才被渲染<br>created创建后$el就不是undefined了</p>
<h4 id="下面关于js框架说法正确的是（-ABD-）"><a href="#下面关于js框架说法正确的是（-ABD-）" class="headerlink" title="下面关于js框架说法正确的是（ ABD   ）"></a>下面关于js框架说法正确的是（ ABD   ）</h4><p>Vue是一个MVVM框架<br>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件<br>Vue中可以使用 v-for 指令来循环对象<br>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定</p>
<hr>
<h1 id="ReactJS"><a href="#ReactJS" class="headerlink" title="ReactJS"></a>ReactJS</h1><h2 id="React的原理和背景"><a href="#React的原理和背景" class="headerlink" title="React的原理和背景"></a>React的原理和背景</h2><ol>
<li>React不是完整的MVC，MVVM框架，特点就是轻，组件高度可重用，React中最重要的就是引入了虚拟DOM的机制。</li>
<li>在Web开发中，我们总需要把变化的数据实时反映到页面的UI上，改变UI就需要操作DOM，而复杂又频繁的DOM操作通常是性能产生瓶颈的原因，因此React引入了虚拟DOM的机制：在客户端js实现了一套DOM API。</li>
<li>基于React进行开发时，所有的DOM构造都是通过虚拟DOM进行的，每当数据发生变化时，React都会进行重新构建整个虚拟DOM树，然后React将当前整个虚拟DOM树和上一次的DOM树进行比较，得到DOM结构哪里发生了变化，然后仅仅将需要变化的部分在浏览器上进行更新。虚拟DOM是存在内存中的，相当于在内存中有一个虚拟的DOM树，在react中有个state,传值需要通过state，它会进行状态变化比较，改变了的地方进行真实的DOM操作。</li>
<li>这个算法叫做Diff算法，这是一种基于红黑树的算法，它会计算虚拟DOM到实际渲染DOM结构的最少步骤。</li>
<li>而且React能够批处理虚拟DOM的刷新，在一个事件循环内的两次数据变化都会合并。比如在极短的时间内，一个节点先从A变成B，再从B变回A，那么React会认为UI没有发生变化。</li>
<li>尽管每一次都需要构造完整的DOM树，但是因为虚拟DOM是内存数据，性能极高，因而能达到提高性能的目的。并且在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或者多个具体的DOM元素上，值需要关心在一个数据状态下，整个界面是如何渲染的。</li>
</ol>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>在react中，你按照界面模板自然划分的方式来组织和编写你的代码，对于普通评论界面而言，整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立。</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ol>
<li>编译器——jsxTransformer<br>JSX代码并不能直接运行，需要将它编译成正常的JavaScript表达式才能运行，jsxTransformer.js就是这一编译器的角色。</li>
<li>第二代编译器——babel<br>&lt;script type=”text/babel”&gt;<br>React官方博客发布了一篇文章，声明其自身用于JSX语法解析的编译器JSTransform已经过期，不再维护，React JS和React Native已经全部采用第三方Babel的JSX编译器实现。原因是两者在功能上已经完全重复，而Babel作为专门的JavaScript语法编译工具，提供了更为强大的功能。而browser.js是babel编译器的浏览器版本。<br>2.1 &lt;script&gt; 标签的 type 属性为 text/babel 。这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=”text/babel”<br>react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。<br>2.2 react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js的作用是将JSX语法转为JavaScript语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。</li>
</ol>
<h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2><ol>
<li><p>使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。我们不需要一定使用 JSX，但它有以下优点：</p>
<ul>
<li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li>
<li>它是类型安全的，在编译过程中就能发现错误。</li>
<li>使用 JSX 编写模板更加简单快速。</li>
</ul>
</li>
<li><p>JSX 允许在模板中插入数组，数组会自动展开所有成员</p>
<p>   var arr = [</p>
<pre><code>  &lt;h1&gt;123&lt;/h1&gt;,
  &lt;h2&gt;321&lt;/h2&gt;,
];
&lt;div&gt;{arr}&lt;/div&gt; 
</code></pre></li>
</ol>
<h2 id="React-State-状态"><a href="#React-State-状态" class="headerlink" title="React State(状态)"></a>React State(状态)</h2><ol>
<li>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</li>
<li>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</li>
<li>创建了 XXX 组件，getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。</li>
</ol>
<h2 id="React-Props"><a href="#React-Props" class="headerlink" title="React Props"></a>React Props</h2><blockquote>
<p>state 和 props 主要的区别在于props是不可变的，而state可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。</p>
</blockquote>
<ol>
<li>Props 验证使用 propTypes，它可以保证我们的应用组件被正确使用，React.PropTypes 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。</li>
<li>props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。</li>
<li>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟DOM（virtualDOM）。只有当它插入文档以后，才会变成真实的DOM。根据React的设计，所有的DOM变动，都先在虚拟DOM上发生，然后再将实际发生变动的部分，反映在真实DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。</li>
</ol>
<h2 id="React-组件-API"><a href="#React-组件-API" class="headerlink" title="React 组件 API"></a>React 组件 API</h2><p>设置状态：setState<br>替换状态：replaceState<br>设置属性：setProps<br>替换属性：replaceProps<br>强制更新：forceUpdate<br>获取DOM节点：findDOMNode<br>判断组件挂载状态：isMounted</p>
<p>所谓组件，即封装起来的具有独立功能的UI部件。React推荐以组件的方式去重新思考UI构成，将UI上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建。</p>
<p>将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI</p>
<h2 id="React组件应该具有特征"><a href="#React组件应该具有特征" class="headerlink" title="React组件应该具有特征"></a>React组件应该具有特征</h2><ol>
<li>可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件；</li>
<li>可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景；</li>
<li>可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；</li>
</ol>
<h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>MVC的思想让你做到视图-数据-控制器的分离，那么组件化的思考方式则是带来了UI功能模块之间的分离</p>
<h3 id="软件可以分为三个部分"><a href="#软件可以分为三个部分" class="headerlink" title="软件可以分为三个部分"></a>软件可以分为三个部分</h3><p>视图（View）：用户界面<br>控制器（Controller）：业务逻辑<br>模型（Model）：数据保存<br>各部分的通信方式：</p>
<ul>
<li>View传送指令到Controller</li>
<li>Controller完成业务逻辑之后，要求Model改变状态</li>
<li>Model将新的数据发送到View，用户得到反馈</li>
<li>三者之间是一个三角关系，并且所有的通信都是单向的。<br>互动模式：<br>接受用户指令时，MVC可以分成两种方式，一种是通过View接受指令，传递给Controller，另一只是直接通过Controller接受指令。</li>
</ul>
<h2 id="说说react的优点和生命周期"><a href="#说说react的优点和生命周期" class="headerlink" title="说说react的优点和生命周期"></a>说说react的优点和生命周期</h2><ol>
<li>React速度很快<br>React中最重要的就是引入了虚拟DOM的机制。<br>基于React进行开发时，所有的DOM构造都是通过虚拟DOM进行的，每当数据发生变化时，React都会进行重新构建整个虚拟DOM树，然后React将当前整个虚拟DOM树和上一次的DOM树进行比较，得到DOM结构哪里发生了变化，然后仅仅将需要变化的部分在浏览器上进行更新。<br>这个算法叫做Diff算法，这是一种基于红黑树的算法，它会计算虚拟DOM到实际渲染DOM结构的最少步骤。</li>
<li>跨浏览器兼容<br>虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</li>
<li>模块化<br>为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。<br>每个组件都可以进行独立的开发和测试，并且它们可以引入其它组件。这等同于提高了代码的可维护性。</li>
</ol>
<h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p>生命周期共提供了10个不同的API。</p>
<ol>
<li>getDefaultProps<br>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。</li>
<li>getInitialState<br>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。</li>
<li>componentWillMount<br>在完成首次渲染之前调用，此时仍可以修改组件的state。</li>
<li>render<br>必选的方法，创建虚拟DOM，该方法具有特殊的规则：<br>只能通过this.props和this.state访问数据<br>可以返回null、false或任何React组件<br>只能出现一个顶级组件（不能返回数组）<br>不能改变组件的状态<br>不能修改DOM的输出</li>
<li>componentDidMount<br>真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。<br>在服务端中，该方法不会被调用。</li>
<li>componentWillReceiveProps<br>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。<br> componentWillReceiveProps: function(nextProps) {<br>   if (nextProps.bool) {<pre><code>this.setState({
  bool: true
});
</code></pre>   }<br> }</li>
<li>shouldComponentUpdate<br>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。<br>在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用</li>
<li>componentWillUpdate<br>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</li>
<li>componentDidUpdate<br>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。</li>
<li>componentWillUnmount<br>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。不太用，浏览器有垃圾回收机制</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>注释需要写在花括号中 </li>
<li>在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。<br>i == 1 ? ‘True!’ : ‘False’</li>
<li>React 会在指定元素数字后自动添加 px </li>
<li>React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. </li>
<li>React.createClass() 方法用于生成一个组件类</li>
<li>原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离</li>
</ol>
<hr>
<h1 id="ES6篇"><a href="#ES6篇" class="headerlink" title="ES6篇"></a>ES6篇</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>ES6在ES5的基础上增加了许多新功能和新用法，现在js更加倾向于面向对象的语言了，而且用过es6的写法可以大大简化代码。</p>
<p>不过很遗憾的是只有当前的一些高版本的浏览器才支持ES6，因此我们需要ES6的转码器babel，利用nodejs的npm功能就可以下载</p>
<p>ES5里，以function来划分作用域，大括号{}却限定不了var的作用域，我们把它叫做函数作用域。<br>ES6里增加了let,cost，声明在{}，-&gt; “function,if,for”等的变量作用域被限制在块级。<br>块级作用域特点：外部变量不影响内层变量，也不能使用内层变量。</p>
</blockquote>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ol>
<li>所声明的变量，只有在let命令所在的代码块内才有效，这也是es6最大的特点之一：增加了块级作用域。</li>
<li>let不存在变量提升的问题，let声明的变量一定要在let声明之后使用，否则会报错。</li>
<li>暂时性死区：在let命令声明变量之前，该变量都是不可用的。只要会计作用域之内存在let，它所声明的变量就绑定到了这个区域之内，不收外部影响。</li>
<li>暂时性死区的本质就是：只要进入当前作用域，所要使用的变量就已经存在了，但是不可以获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li>
</ol>
<blockquote>
<p>es6明确规定：如果区块中有let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭性作用域，凡是在声明之前就使用这些变量就会报错。</p>
</blockquote>
<h2 id="es6中的暂时性死区和无变量提升"><a href="#es6中的暂时性死区和无变量提升" class="headerlink" title="es6中的暂时性死区和无变量提升"></a>es6中的暂时性死区和无变量提升</h2><blockquote>
<p>● 主要是为了减少运行时的错误，防止在变量声明之前就使用这个变量，从而导致意料之外的错误。<br>● 不允许重复声明：在同一个作用域之内，let和const都不允许重复声明同一个变量，包括变量和形参的名字相同的情况。</p>
</blockquote>
<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><blockquote>
<p>● 主const声明一个只读的常量,const声明的变量不能被修改，这意味着我们只能在声明的同时就赋值，不能先声明后赋值。<br>● 主不过const对于一个引用值来说有点特殊，const只是保证变量指向的地址不变，当我们const声明一个对象或者数组的时候</p>
</blockquote>
<h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><ol>
<li>顶层对象指的就是我们的window这一级别的对象。</li>
<li>在es5中，我们在全局环境声明一个变量，相当于把这个变量挂载到了window对象上面：这就导致了变成人员在写的时候经常会不知不觉地创建了全局变量，这样很不利于模块化变成。</li>
<li>在es6中，var和function 命令声明的全局变量，依然是window的属性，但是let、const、class声明的全局变量，不再是window的属性了。</li>
</ol>
<h2 id="ES6-解构赋值"><a href="#ES6-解构赋值" class="headerlink" title="ES6-解构赋值"></a>ES6-解构赋值</h2><ol>
<li>es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称之为解构赋值。</li>
<li>如果解构失败，变量的值就是undefined</li>
<li><p>如果等号的右边不是数组（或者严格来说，不是可遍历的结构），那么将会报错。</p>
<pre><code>let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
这些都会报错。
</code></pre></li>
<li><p>解构赋值对于var、let、const命令都适用。</p>
</li>
<li><p>解构赋值与允许执行默认值 let [a,b=2] = [1];</p>
</li>
<li>只有数组的值严格等于undefined，才会被赋予默认值，否则即使是null和false也会被正常赋值<pre><code>let [x=1] = [undefined]; // x = 1;
let [x=1] = [null]; // x = null;
</code></pre></li>
<li>默认值可以引用解构赋值的其他变量，但是前提是该变量必须已经声明。          <pre><code>let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=26
let [x = y, y = 1] = [];     // ReferenceError
</code></pre></li>
<li>最后一个之所以会报错，是因为x用到默认值y的时候，y还没有被声明。</li>
</ol>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><blockquote>
<p>对象的解构赋值和数组的解构赋值的区别在于：数组的元素是按照次序排序的，因此它们赋值也是按照顺序赋值的，<br>但是对象的属性是没有次序的，变量必须与属性同名，才会被赋值。</p>
</blockquote>
<pre><code>var {a,b} = {b:&apos;234&apos;,a:123};
// a = 123;
// b = &apos;234&apos;;
</code></pre><p>对象的解构赋值的内部机制是：先找到同名的属性，然后把这个属性值赋予给对应的变量。</p>
<pre><code>{a:demo} = {a:123};
//demo 123
a只是一个匹配模式，模式是不会被赋值的。
</code></pre><h3 id="字符串也可以被解构赋值，和数组非常类似"><a href="#字符串也可以被解构赋值，和数组非常类似" class="headerlink" title="字符串也可以被解构赋值，和数组非常类似"></a>字符串也可以被解构赋值，和数组非常类似</h3><pre><code>const [a, b, c, d, e] = &apos;hello&apos;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre><p>由于类数组和对象都有length属性，我们还可以专门对这个属性进行解构赋值：</p>
<pre><code>let {length : len} = &apos;hello&apos;;
len // 5
</code></pre><p>解构赋值的时候，如果等号右边是数组和布尔值，则会有限转化成对象。<br>由于undefined和null无法转化为对象，所以对他们进行解构赋值都会报错。</p>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><pre><code>function move({x = 0, y = 0} = {}) {
return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><p>参数的解构赋值也可以有默认值，当我们不传入实参的时候就会赋值为默认值。<br>但是要注意这种写法和下面这一种是不一样的：</p>
<pre><code>function move({x, y} = { x: 0, y: 0 }) {
return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
</code></pre><blockquote>
<p>二者的主要区别在于默认值的写法上，第一种是给x、y变量指定默认值，而第二种是给move函数指定默认值而不是x、y变量。这一点一定要注意！！<br>还有一点：圆括号可能会对解构赋值带来影响，因此能不用圆括号就不用。</p>
</blockquote>
<h2 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h2><ol>
<li><p>交换变量    </p>
<ul>
<li>[x, y] = [y, x];</li>
</ul>
</li>
<li><p>函数可以有多个返回值        </p>
<ul>
<li>return [1, 2, 3];</li>
<li>然后可以通过解构赋值给多个变量赋值</li>
</ul>
</li>
<li><p>函数参数的定义</p>
<ul>
<li>解构赋值可以方便的把形参和实参对应起来，只需要形参是一个对象即可，不需要是按照固定的顺序写实参，就像我们在es5中用的json参数一样         </li>
<li>function f({x, y, z}) { … }<br>f({z: 3, y: 2, x: 1});</li>
</ul>
</li>
<li><p>提取JSON数据        </p>
<ul>
<li>let { id, status, data: number } = json;</li>
<li>不仅仅是json，只要是个对象我们都可以把属性值快速的提取出来。</li>
</ul>
</li>
<li><p>函数参数的默认值</p>
</li>
<li><p>遍历Map解构</p>
<ul>
<li>map可以用for…of循环遍历，解构赋值可以方便获得键/值。而且可以只获取键名或者键值</li>
</ul>
</li>
<li><p>配合requireJS         </p>
<ul>
<li>const {src} = require(‘source’);</li>
<li>这样可以直接获取source模块中的src变量。</li>
<li>当然也可以配合es6中的import来使用</li>
</ul>
</li>
</ol>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><ol>
<li>Array.from()<br> 这个方法用于将类数组和可比遍历的对象（包括es6的Set和Map数据结构）转化成真正的数组。</li>
<li>Array.from()还接受第二个参数，作用类似数组的map方法，用来对每个元素进行处理，然后将处理后的值放入到返回的数组中。</li>
<li>Array.from()的另一个应用是，将字符串转化成数组，然后返回字符串的长度。<br>因为它能够正确处理各种Unicode字符，可以避免Javascrit将大于\uFFFF的Unicode字符算成两个字符的bug。</li>
</ol>
<h2 id="Set和Map是es6新增的两个数据结构"><a href="#Set和Map是es6新增的两个数据结构" class="headerlink" title="Set和Map是es6新增的两个数据结构"></a>Set和Map是es6新增的两个数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>Set和数组很相似，但是它的成员的值都是唯一的，没有重复值。Set实例的方法分为了两大类：操作方法和遍历方法。</p>
</blockquote>
<h4 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h4><ol>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ol>
<h4 id="遍历方法："><a href="#遍历方法：" class="headerlink" title="遍历方法："></a>遍历方法：</h4><ol>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ol>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><blockquote>
<p>WeakSet结构和Set很相似，主要有两个区别：<br>● WeakSet的成员只能是对象，不能是其他类型的值。<br>● WeakSet中的对象都是若引用，即垃圾回收机制不会考虑WeakSet对该对象的引用，也就是说，如果有其他对象都不在引用该对象，<br>那么垃圾回收机制会自动回收该对象所占用的内存，不考虑它是否在WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可以遍历的。</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><blockquote>
<p>Map主要是解决传统es5中的键值对的键名只能是字符串的问题而引入的一种结构 。在Map中，键值名不限于字符串，可以使各种类型的值。</p>
</blockquote>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><blockquote>
<p>Promise是异步编程的一种解决方案，所谓的Promise，简单来说就是一个容器，里面保存着未来才会结束的事件的结果。</p>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>对象的状态不受外界影响。Promise对象代表一种异步操作，有三种状态：Pending(进行中)、Resolved(已完成)、Rejected(已失败)。</li>
<li>只有异步操作的结果可以改变状态，其他的任何操作都不能改变状态。</li>
<li>一旦状态改变了，就不会再变了，任何时候都可以得到这个结果。Promise对象的状态只有两种可能：Pending-&gt;Resolved或者Pending-&gt;Rejected。</li>
<li>只要这两种情况发生了，状态就不会再改变了，并且会一直保持这个结果。这与事件监听不同，事件的特点是，不同时间监听，得到的结果都是不同的。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>首先无法取消Promise，一旦创建他就会立即执行，中途无法取消。</li>
<li>其次，如果还不设置回调函数，Promise内部跑出的错误，不会反映到外部。</li>
<li>最后，当处于Pending状态时，无法得知目前进展到哪一个阶段了。</li>
</ol>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote>
<p>Promise对象是一个构造函数，用来生成Promise实例的。</p>
</blockquote>
<pre><code>var promise = new Promise(function(resolve, reject) {
// ... some code
if (/* 异步操作成功 */){
    resolve(value);
} else {
    reject(error);
}
});
</code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。他们是两个函数，由js引擎提供，不需要自己部署。</p>
<h3 id="resolve函数的作用"><a href="#resolve函数的作用" class="headerlink" title="resolve函数的作用"></a>resolve函数的作用</h3><blockquote>
<p>将Promise对象的状态从“未成功”变成“成功”（Pending-&gt;Resolved），在异步操作成功时调用，并将一步操作的结果，作为参数传递出去。</p>
</blockquote>
<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p>
<pre><code>promise.then(function(value) {
// success
}, function(error) {
// failure
});
</code></pre><blockquote>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变成Rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
</blockquote>
<p>这里我们就可以用Promise来异步加载图片</p>
<pre><code>function loadImageAsync(url) {
      return new Promise(function(resolve, reject) {
        var image = new Image();
        image.onload = function() {
          resolve(image);
        };
        image.onerror = function() {
           reject(new Error(&apos;Could not load image at &apos; + url));
        };
        image.src = url;
    });
    }
</code></pre><blockquote>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
</blockquote>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) {
      return json.post;
      }).then(function(post) {
      // ...
      });
</code></pre><p>这一段代码中使用了then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数中。</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote>
<p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
</blockquote>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(posts) {
    // ...
    }).catch(function(error) {
    // 处理 getJSON 和 前一个回调函数运行时发生的错误
    console.log(&apos;发生错误！&apos;, error);
    });
</code></pre><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><blockquote>
<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。<br>● var p = Promise.all([p1, p2, p3]);<br>● 当p1p2p3的状态都是resolved的时候，p的状态才是resolved，否则只要有一个是rejected，那么p的状态就时rejected。</p>
</blockquote>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><blockquote>
<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。<br>● var p = Promise.all([p1, p2, p3]);<br>● 当p1p2p3的状态都是resolved的时候，p的状态才是resolved，否则只要有一个是rejected，那么p的状态就时rejected。</p>
</blockquote>
<h3 id="Promise-race-1"><a href="#Promise-race-1" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><blockquote>
<p>Promise.race()方法同样是将多个Promise实例，包装成一个新的Promise实例，用法和all是一样的。<br>它与all的不同在于：race是只要有一个状态改变了，p的状态就会改变，并且变成和第一个状态改变之后的一样的状态。</p>
</blockquote>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><blockquote>
<p>有时候需要将现有的对象转为Promise对象，Promise.resolve方法就起到这个作用。<br>Promise.resolve(‘foo’)<br>// 等价于new Promise(resolve =&gt; resolve(‘foo’))</p>
</blockquote>
<h4 id="Promise-resolve方法的参数分为四种情况"><a href="#Promise-resolve方法的参数分为四种情况" class="headerlink" title="Promise.resolve方法的参数分为四种情况"></a>Promise.resolve方法的参数分为四种情况</h4><ol>
<li><p>参数是一个Promise实例</p>
<ul>
<li>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返 回这个实例。</li>
</ul>
</li>
<li><p>参数是一个thenable对象</p>
<ul>
<li>thenable对象指的是具有then方法的对象，比如下面这个对象。</li>
<li>Promise.resolve方法会将这个对象转为Promise对象，然后立即执行thenable对象的then方法。</li>
</ul>
</li>
<li><p>参数不是具有then方法的对象，或根本就不是对象</p>
<ul>
<li>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve 方法返回一个新的Promise对象，状态为Resolved</li>
</ul>
</li>
<li><p>Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。</p>
</li>
</ol>
<p>所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><blockquote>
<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一样。</p>
</blockquote>
<h3 id="其他两个附加方法"><a href="#其他两个附加方法" class="headerlink" title="其他两个附加方法"></a>其他两个附加方法</h3><ol>
<li><p>done()方法</p>
<blockquote>
<p>● Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。<br>● 因此，我们可以提供一个done方法，总是处于 回调链的尾端，保证抛出任何可能出现的错误。</p>
</blockquote>
</li>
<li><p>finally()方法</p>
<blockquote>
<p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法最大的区别就在于，它接受一个普通的回调函数作为参数，该参数不管怎样都必须执行。类似try catch finally里面的finally。</p>
</blockquote>
</li>
</ol>
<h2 id="使用箭头函数有几个注意点"><a href="#使用箭头函数有几个注意点" class="headerlink" title="使用箭头函数有几个注意点"></a>使用箭头函数有几个注意点</h2><ol>
<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</li>
<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
</li>
<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
</li>
<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
</li>
</ol>
<blockquote>
<p>● 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。<br>● this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。<br>● 正是因为它没有this，所以也就不能用作构造函数。</p>
</blockquote>
<h2 id="怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢"><a href="#怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢" class="headerlink" title="怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢"></a>怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢</h2><p>普通函数中的this:</p>
<ol>
<li>this总是代表它的直接调用者, 例如 obj.func ,那么func中的this就是obj</li>
<li>在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window</li>
<li>在严格模式下,没有直接调用者的函数中的this是 undefined</li>
<li>使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象</li>
</ol>
<p>箭头函数中的this<br>默认指向在定义它时,它所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window</p>
<h2 id="总的来说"><a href="#总的来说" class="headerlink" title="总的来说"></a>总的来说</h2><blockquote>
<p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念</p>
</blockquote>
<hr>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>博主会持续更新，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/weixinprice.png" alt="Candice Yu WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/uploads/zhifubaoprice.jpg" alt="Candice Yu Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/VUE/" rel="tag">#VUE</a>
          
            <a href="/tags/reactJS/" rel="tag">#reactJS</a>
          
            <a href="/tags/ES6/" rel="tag">#ES6</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/01/前端知识总结（VUE，reactJS，ES6）/" rel="next" title="前端知识总结（VUE，reactJS，ES6）">
                <i class="fa fa-chevron-left"></i> 前端知识总结（VUE，reactJS，ES6）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/01/前端知识总结（优化，兼容）/" rel="prev" title="前端知识总结（性能优化，兼容）">
                前端知识总结（性能优化，兼容） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/11/01/前端知识总结（VUE，reactJS）/"
           data-title="前端知识总结（VUE，reactJS，ES6）" data-url="http://candiceyu.com/2017/11/01/前端知识总结（VUE，reactJS）/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="Candice Yu" />
          <p class="site-author-name" itemprop="name">Candice Yu</p>
          <p class="site-description motion-element" itemprop="description">I don’t want to earn my living; i want to live.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/dreamgirla" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/5329295f3aea/timeline" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-jianshu"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/#signin" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-zhihu"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://carryguan.me/" title="Carry" target="_blank">Carry</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://yuanguangxin.me/" title="yuanguangxin" target="_blank">yuanguangxin</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#VUE总结"><span class="nav-text">VUE总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#VUE和jQuery的区别"><span class="nav-text">VUE和jQuery的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VUE1-0和VUE2-0的区别"><span class="nav-text">VUE1.0和VUE2.0的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生命周期"><span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算属性computed-vs-Methods-methods"><span class="nav-text">计算属性computed: {} vs Methods methods: {}</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Computed-属性-vs-Watched-属性"><span class="nav-text">Computed 属性 vs Watched 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key管理可复用的元素"><span class="nav-text">key管理可复用的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-show"><span class="nav-text">v-show</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for"><span class="nav-text">v-for</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件处理器"><span class="nav-text">事件处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法事件处理器"><span class="nav-text">方法事件处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件修饰符"><span class="nav-text">事件修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键值修饰符"><span class="nav-text">键值修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表单控件绑定"><span class="nav-text">表单控件绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文本"><span class="nav-text">文本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复选框"><span class="nav-text">复选框</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修饰符"><span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件"><span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#data-必须是函数-通过Vue构造器传入的各种选项大多数都可以在组件里用。-data-是一个例外，它必须是函数。"><span class="nav-text">data 必须是函数,通过Vue构造器传入的各种选项大多数都可以在组件里用。 data 是一个例外，它必须是函数。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构成组件"><span class="nav-text">构成组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Prop-传递数据"><span class="nav-text">使用 Prop 传递数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态-Prop"><span class="nav-text">动态 Prop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单向数据流"><span class="nav-text">单向数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prop-验证"><span class="nav-text">Prop 验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义事件"><span class="nav-text">自定义事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子组件索引"><span class="nav-text">子组件索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue面试题"><span class="nav-text">Vue面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-js是什么"><span class="nav-text">Vue.js是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VueJS-特性："><span class="nav-text">VueJS 特性：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用MVVM模式有几大好处"><span class="nav-text">使用MVVM模式有几大好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟DOM有利也有弊。"><span class="nav-text">虚拟DOM有利也有弊。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-js特点"><span class="nav-text">Vue.js特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue中的MVVM模式"><span class="nav-text">vue中的MVVM模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"><span class="nav-text">mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令和用法"><span class="nav-text">指令和用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#说出至少4种vue当中的指令和它的用法？"><span class="nav-text">说出至少4种vue当中的指令和它的用法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-show指令，v-if的区别"><span class="nav-text">v-show指令，v-if的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令v-el的使用"><span class="nav-text">指令v-el的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令keep-alive"><span class="nav-text">指令keep-alive</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#钩子函数"><span class="nav-text">钩子函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-router有哪几种导航钩子？"><span class="nav-text">vue-router有哪几种导航钩子？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导航钩子有哪些？它们有哪些参数？"><span class="nav-text">导航钩子有哪些？它们有哪些参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"><span class="nav-text">自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuejs组件"><span class="nav-text">Vuejs组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#认识vuex"><span class="nav-text">认识vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#你是怎么认识vuex的？"><span class="nav-text">你是怎么认识vuex的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vuex是什么？怎么使用？哪种功能场景使用它？"><span class="nav-text">vuex是什么？怎么使用？哪种功能场景使用它？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-js-和-AngularJS-之间的区别是什么"><span class="nav-text">Vue.js 和 AngularJS 之间的区别是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-js-和-React-js-有什么区别"><span class="nav-text">Vue.js 和 React.js 有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue的双向数据绑定原理是什么？（vue-data是怎么实现的？）"><span class="nav-text">Vue的双向数据绑定原理是什么？（vue data是怎么实现的？）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请详细说下你对vue生命周期的理解？"><span class="nav-text">请详细说下你对vue生命周期的理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请说下封装-vue-组件的过程？"><span class="nav-text">请说下封装 vue 组件的过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-router插件"><span class="nav-text">vue-router插件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><span class="nav-text">怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-router是什么？它有哪些组件？"><span class="nav-text">vue-router是什么？它有哪些组件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路由嵌套"><span class="nav-text">路由嵌套</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#active-class是哪个组件的属性？嵌套路由怎么定义？"><span class="nav-text">active-class是哪个组件的属性？嵌套路由怎么定义？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vuejs中使用事件名"><span class="nav-text">vuejs中使用事件名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他问题"><span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何让css只在当前组件中起作用"><span class="nav-text">如何让css只在当前组件中起作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-model是什么？怎么使用？-vue中标签怎么绑定事件？"><span class="nav-text">v-model是什么？怎么使用？ vue中标签怎么绑定事件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-loader是什么？使用它的用途有哪些？"><span class="nav-text">vue-loader是什么？使用它的用途有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下列关于vue的组件说法不正确的是（-D-）"><span class="nav-text">下列关于vue的组件说法不正确的是（ D   ）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下面关于vue的声明周期说法不正确的是（-D-）"><span class="nav-text">下面关于vue的声明周期说法不正确的是（  D  ）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下面关于js框架说法正确的是（-ABD-）"><span class="nav-text">下面关于js框架说法正确的是（ ABD   ）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReactJS"><span class="nav-text">ReactJS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#React的原理和背景"><span class="nav-text">React的原理和背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件化"><span class="nav-text">组件化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器"><span class="nav-text">编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSX语法"><span class="nav-text">JSX语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-State-状态"><span class="nav-text">React State(状态)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-Props"><span class="nav-text">React Props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-组件-API"><span class="nav-text">React 组件 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React组件应该具有特征"><span class="nav-text">React组件应该具有特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC模式"><span class="nav-text">MVC模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件可以分为三个部分"><span class="nav-text">软件可以分为三个部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说react的优点和生命周期"><span class="nav-text">说说react的优点和生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件生命周期"><span class="nav-text">组件生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6篇"><span class="nav-text">ES6篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#let"><span class="nav-text">let</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#es6中的暂时性死区和无变量提升"><span class="nav-text">es6中的暂时性死区和无变量提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const命令"><span class="nav-text">const命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顶层对象的属性"><span class="nav-text">顶层对象的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-解构赋值"><span class="nav-text">ES6-解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的解构赋值"><span class="nav-text">对象的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串也可以被解构赋值，和数组非常类似"><span class="nav-text">字符串也可以被解构赋值，和数组非常类似</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数参数的解构赋值"><span class="nav-text">函数参数的解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解构赋值的用途"><span class="nav-text">解构赋值的用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的扩展"><span class="nav-text">数组的扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set和Map是es6新增的两个数据结构"><span class="nav-text">Set和Map是es6新增的两个数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作方法："><span class="nav-text">操作方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历方法："><span class="nav-text">遍历方法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakSet"><span class="nav-text">WeakSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise"><span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#含义"><span class="nav-text">含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法"><span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resolve函数的作用"><span class="nav-text">resolve函数的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-prototype-catch"><span class="nav-text">Promise.prototype.catch()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-all"><span class="nav-text">Promise.all()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-race"><span class="nav-text">Promise.race()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-race-1"><span class="nav-text">Promise.race()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-resolve"><span class="nav-text">Promise.resolve()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-resolve方法的参数分为四种情况"><span class="nav-text">Promise.resolve方法的参数分为四种情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-reject"><span class="nav-text">Promise.reject()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他两个附加方法"><span class="nav-text">其他两个附加方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用箭头函数有几个注意点"><span class="nav-text">使用箭头函数有几个注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢"><span class="nav-text">怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总的来说"><span class="nav-text">总的来说</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Candice Yu</span>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"candiceyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

</body>
</html>
